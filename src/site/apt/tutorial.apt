~~
~~ Copyright 2006 the original author or authors.
~~
~~ Licensed under the Apache License, Version 2.0 (the "License");
~~ you may not use this file except in compliance with the License.
~~ You may obtain a copy of the License at
~~
~~      http://www.apache.org/licenses/LICENSE-2.0
~~
~~ Unless required by applicable law or agreed to in writing, software
~~ distributed under the License is distributed on an "AS IS" BASIS,
~~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~~ See the License for the specific language governing permissions and
~~ limitations under the License.
~~
Tutorial

    This tutorial describes more complex configuration of Spring WS test. We will show more complex response generators and we will
    also show how to use request validators. 

	Let's imagine that we write Airline Aggregator application. This application calls several underlying Airline web services and aggregates the results. 
	It is possible to write Unit test, but let's imagine that we want to write more complex automated tests that include test of the configuration, 
	integration with the framework etc. In this tutorail we assume that you already have working Spring WS configuration like this.
	
---
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="airlineAggregator" class="net.javacrumbs.airline.aggregator.AirlineAggregator">
		<property name="serviceUris">
			<list>
				<value>http://www.aerlingus.com/ws/</value>
				<value>http://www.csa.cz/gateway/</value>
			</list>
		</property>
		<property name="template" ref="wsTemplate"/>
	</bean>
	
	 <bean id="wsTemplate" class="org.springframework.ws.client.core.WebServiceTemplate">
		<property name="marshaller" ref="marshaller"/>
		<property name="unmarshaller" ref="marshaller"/>
	</bean>	
	
	<bean id="marshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller">
		<property name="contextPath" value="net.javacrumbs.airline.aggregator.jaxb"/>
	</bean>
	
	
</beans>
---     

* MockWebServiceMessageSender
  
   First of all, we have to create a new Spring configuration file "dummy-message-sender.xml" and define <<<MockWebServiceMessageSender>>> there. 

---
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<!-- Creates mock message sender -->
	<bean id="messageSender" class="net.javacrumbs.springws.test.MockWebServiceMessageSender"/>
	
	<!-- Injects mock message sender into WebServiceTemplate -->
	<bean class="net.javacrumbs.springws.test.util.MockMessageSenderInjector"/>
</beans>
---

   By using <<<MockMessageSenderInjector>>> we can automagically inject mock message sender into <<<WebServiceTemplate>>>. 
   

* Response Generator

	<<<MockWebServiceMessageSender>>> needs at least one response generator. We can define one by adding this declaration into "dummy-message-sender.xml".
	
---
<!-- Looks for responses on the disc based on the provided XPath -->
<bean class="net.javacrumbs.springws.test.generator.DefaultResponseGeneratorFactoryBean">
	<property name="namespaceMap">
		<map>
			<entry key="soapenv" value="http://schemas.xmlsoap.org/soap/envelope/"/>
			<entry key="ns" value="http://www.springframework.org/spring-ws/samples/airline/schemas/messages"/>
		</map>
	</property>
	<property name="XPathExpressions">
		<list>
			<value>concat('mock-responses/',$uri.host, '/', local-name(//soapenv:Body/*[1]),'/',//ns:from,'-',//ns:to,'-response.xml')</value>
			<value>concat('mock-responses/',$uri.host, '/', local-name(//soapenv:Body/*[1]),'/default-response.xml')</value>
		</list>
	</property>		
</bean>		
---  

  This definition says that for every request the XPath <<<concat('mock-responses/',$uri.host, '/', local-name(//soapenv:Body/*[1]),'/',//ns:from,'-',//ns:to,'-response.xml')>>> should be evaluated first.
  Result of the evaluation can be for example <<<mock-responses/www.csa.cz/GetFlightsRequest/PRG-JFK-response.xml>>>. If this file exists, its content will be returned as 
  the response. If the file does not exists, next XPath expression is evaluated. If even <<<mock-responses/www.csa.cz/GetFlightsRequest/default-response.xml>>> does not exist, an exception is thrown.
  
  If we have this or similar configuration, adding an extra mock response consists only from creating new file with correct path and name.
  
  Please note that MockWebServiceMessageSender is automatically looking for all RequestValidator instances in the application context.
  
* XSLT mock response
  
  Sometimes creating an extra response file for every possible request is just too much work. Sometime you just need to tweak the response a bit before using it. 
  Luckily you can use a XSLT template to generate the response based on the request. For example you can specify response like this
  
---
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
	<xsl:param name="departureTime"/>
	<xsl:template match="/">
		<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
			<soapenv:Header />
			<soapenv:Body>
				<GetFlightsResponse
					xmlns="http://www.springframework.org/spring-ws/samples/airline/schemas/messages"
					xmlns:msg="http://www.springframework.org/spring-ws/samples/airline/schemas/messages"
					xmlns:tps="http://www.springframework.org/spring-ws/samples/airline/schemas/types">
					<flight>
						<tps:number>OK0651</tps:number>
						<tps:departureTime><xsl:value-of select="$departureTime"/></tps:departureTime>
						<tps:from>
							<tps:code>PRG</tps:code>
							<tps:name>Prague</tps:name>
							<tps:city>Prague</tps:city>
						</tps:from>
						<tps:arrivalTime>2001-12-31T12:00:00
						</tps:arrivalTime>
						<tps:to>
							<tps:code>CDG</tps:code>
							<tps:name>CDG</tps:name>
							<tps:city>Paris</tps:city>
						</tps:to>
						<tps:serviceClass><xsl:value-of select="//msg:serviceClass"/></tps:serviceClass>
					</flight>
				</GetFlightsResponse>
			</soapenv:Body>
		</soapenv:Envelope>
	</xsl:template>
</xsl:stylesheet>
---

  Instead of simple XML response, we have XSLT that uses the <<<serviceClass>>> from the request and <<<departureTime>>> from the test context
  (more about the context later).   
  
* Validating request

  In the case you want to validate requests. You can configure request validator. Currently, two validators are supported.
  
** SchemaRequestValidator

  Schema request validator validates whether the request conforms to given schema 
  
---
<bean class="net.javacrumbs.springws.test.validator.SchemaRequestValidator">
	<property name="schemas">
		<list>
			<value>xsd/messages.xsd</value>
			<value>xsd/types.xsd</value>
		</list>
	</property>
</bean>
---	

   When configured like this, every request is validated using specified schemas. If the request is not valid <<<WsTestException>>> is thrown.
   
** XmlCompareRequestValidator

  You can find this validator useful for Test Driven Development. It compares the request with specified file 
  
---
	<bean class="net.javacrumbs.springws.test.validator.XmlCompareRequestValidatorFactoryBean">
		<property name="namespaceMap">
			<map>
				<entry key="soapenv" value="http://schemas.xmlsoap.org/soap/envelope/"/>
				<entry key="ns" value="http://www.springframework.org/spring-ws/samples/airline/schemas/messages"/>
			</map>
		</property>
		<property name="XPathExpressions">
			<list>
				<value>concat('mock-responses/',$uri.host, '/', local-name(//soapenv:Body/*[1]),'/',//ns:from,'-',//ns:to,'-request.xml')</value>
			</list>
		</property>		
	</bean>		
---

  It's similar to the request generator, the difference is that instead of generating responses it validates the request. You can use XSLT templates here as well. 
  You can also specify special placeholder <<<${IGNORE}>>> for values that should be ignored.

* Test context

  Test context is useful, when you need to use some specific configuration. For example you want to set expected departure time and use it in the response.
 
---
WsTestContextHolder.getTestContext().setAttribute("departureTime", "2009-07-14");
--- 

  You can set the attribute in the test method and then use it 
  
  * In the XSLT template as a template parameter.
  
  * In the XPath using <<<$context.departureTime>>>
  
  * Programatically
  
  It's a good idea to clear the test context at the tearDown() method.
  
    
     