~~
~~ Copyright 2009-2010 the original author or authors.
~~
~~ Licensed under the Apache License, Version 2.0 (the "License");
~~ you may not use this file except in compliance with the License.
~~ You may obtain a copy of the License at
~~
~~      http://www.apache.org/licenses/LICENSE-2.0
~~
~~ Unless required by applicable law or agreed to in writing, software
~~ distributed under the License is distributed on an "AS IS" BASIS,
~~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~~ See the License for the specific language governing permissions and
~~ limitations under the License.
~~
   ------
   Client test tutorial
   ------
~~
~~ Copyright 2006 the original author or authors.
~~
~~ Licensed under the Apache License, Version 2.0 (the "License");
~~ you may not use this file except in compliance with the License.
~~ You may obtain a copy of the License at
~~
~~      http://www.apache.org/licenses/LICENSE-2.0
~~
~~ Unless required by applicable law or agreed to in writing, software
~~ distributed under the License is distributed on an "AS IS" BASIS,
~~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~~ See the License for the specific language governing permissions and
~~ limitations under the License.
~~
Client Test Tutorial

   This page provides a step-by-step tutorial of WS client testing. In the tutorial we will test a simple calculator web service. The source code of
   the sample application is downloadable {{{https://java-crumbs.svn.sourceforge.net/svnroot/java-crumbs/simple-client-test/tags/simple-client-test-${currentVersion}/simple-client-test/}from SVN repository}}.
   
   It's possible to download it using following command <<<svn co https://java-crumbs.svn.sourceforge.net/svnroot/java-crumbs/simple-client-test/tags/simple-client-test-0.12/simple-client-test/ simple-client-test>>>
	
* Tested application 

	 Its XSD look like this
	
---
<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://javacrumbs.net/calc"
	xmlns:tns="http://javacrumbs.net/calc" elementFormDefault="qualified">

	<element name="plus">
		<complexType>
			<sequence>
				<element name="a" type="int" />
				<element name="b" type="int" />
			</sequence>
		</complexType>
	</element>

	<element name="result">
		<complexType>
			<sequence>
				<element name="result" type="int" />
			</sequence>
		</complexType>
	</element>
</schema>
--- 

   There is one "operation" called <<<plus>>> allowing us to add two numbers. The result is returned in the <<<result>>> element. 

   Spring configuration (client-config.xml) is simple as well.
   
---
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean class="net.javacrumbs.calc.Calc"/>
	
	<bean id="wsTemplate" class="org.springframework.ws.client.core.WebServiceTemplate">
		<property name="defaultUri" value="http://localhost/calc"/>
		<property name="marshaller" ref="marshaller"/>
		<property name="unmarshaller" ref="marshaller"/>
	</bean>	
	
	<bean id="marshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller">
		<property name="contextPath" value="net.javacrumbs.calc.model"/>
	</bean>
</beans>
---

   The only noteworthy part is, that JAXB2 marshaller is used. JAXB classes can be generated by Maven, using configuration like this {{{https://java-crumbs.svn.sourceforge.net/svnroot/java-crumbs/simple-client-test/tags/simple-client-test-${currentVersion}/simple-client-test/pom.xml}one}}.   
   
   The client code is also simple, we just have to create request payload, send it to WS template and extract the response.
   
---
public class Calc {
	@Autowired
	private WebServiceOperations wsTemplate;
	
	public int plus(int a, int b)
	{
		Plus request = new Plus();
		request.setA(a);
		request.setB(b);
		Result result = (Result) wsTemplate.marshalSendAndReceive(request);
		return result.getResult();
	}
}
---

* The Test
  
  Now when the tested code is clear, we can focus on the test itself. Let's start with first simple test
  
** Response Generation

---
@RunWith(SpringJUnit4ClassRunner.class)
//load your standard config
@ContextConfiguration(locations={"classpath:client-config.xml"})
//Add the listener (DirtiesContextTestExecutionListener.class,  TransactionalTestExecutionListener.class might be needed if @DirtiesContext or @Transactional is used.
@TestExecutionListeners({WsMockControlTestExecutionListener.class, DependencyInjectionTestExecutionListener.class})
public class CalcTest {
    @Autowired
    private Calc calc;
    
    //inject mock control
    @Autowired
    private WsMockControl mockControl;

	@Test
	public void testSimple()
	{
		mockControl.returnResponse("response1.xml");

		int result = calc.plus(1, 2);
		assertEquals(3, result);
		
		mockControl.verify();
	}
}
---   

   The code starts with {{{http://static.springsource.org/spring/docs/2.5.x/reference/testing.html#testcontext-ctx-management}standard Spring JUnit support}}.
   The TestExecutionListener configuration is the important bit. In addition to standard Spring listeners, WsMockControlTestExecutionListener.class is used. The listener does all the magic
   - it makes WsMockControl bean available, alters WsTemplate so no server is called and in general, it makes sure that everything works.
   
   Once we have WsMockControl, we can write the test. First of all, it's necessary to define which response should be returned from the web service call.
   That's achieved by <<<mockControl.returnResponse("response1.xml");>>> call. Then it's possible to call the WS client code. The mock infrastructure kicks in
   and instead of calling remote service, <<<response1.xml>>> is returned. 
   
   It's recommended to verify, that the web service was indeed called. It's done by <<<mockControl.verify();>>>
   
** Request Validation

   Usually it's also useful to verify that the request generated has the expected form. It's easy to achieve this way.
   
---
@Test
public void testVerifyRequest()
{
	mockControl.expectRequest("request1.xml").returnResponse("response1.xml");
	
	int result = calc.plus(1, 2);
	assertEquals(3, result);
	
	mockControl.verify();
}
--- 

   Please note that it's possible to define the requests and responses either as 
   {{{https://java-crumbs.svn.sourceforge.net/svnroot/java-crumbs/simple-client-test/tags/simple-client-test-${currentVersion}/simple-client-test/src/test/resources/response2.xml}full soap messages}} 
   or as {{{https://java-crumbs.svn.sourceforge.net/svnroot/java-crumbs/simple-client-test/tags/simple-client-test-${currentVersion}/simple-client-test/src/test/resources/response1.xml}payload only}}. It depends only on your preference.  

** Schema Validation

   We can also make sure the request conforms to XSD.

---
@Test
public void testSchema()
{
	mockControl.validateSchema("xsd/calc.xsd").expectRequest("request1.xml").returnResponse("response1.xml");
	
	int result = calc.plus(1, 2);
	assertEquals(3, result);
	
	mockControl.verify();
}  
---

** Ignoring Request Values
   
   Even though we could define special request and response file for every possible test it would soon become a maintenance nightmare. 
   Therefore there are few mechanisms that allows us to reuse request and response files. The first one is <<<${IGNORE}>>> placeholder.
   
   It's possible to ignore some parts of the request when comparing it to generated value.
   
---
<plus xmlns="http://javacrumbs.net/calc">
  <a>${IGNORE}</a>
  <b>${IGNORE}</b>
</plus>
---

   This "template" can be reused for all possible tests. Values of <<<a>>> and <<<b>>> are ignored.
   
** Response Templates

  Similar mechanism can be used for responses too. In response, it's not possible just to simply ignore some values, we have to generate them. One way of achieving 
  it is to use XSLT template.
  
---
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:template match="/">
			<result xmlns="http://javacrumbs.net/calc" xmlns:c="http://javacrumbs.net/calc">
			  <result><xsl:value-of select="//c:a + //c:b"/></result>
			</result>
		</xsl:template>
</xsl:stylesheet>
---

   This template takes value from requests and calculates the response. Here we have in fact implemented the service using the template, but in more real-life like scenarions
   it's useful too. It's possible to generate the response based on the request values. Even though XSLT is quite powerful toll, FreeMarker templates 
   are supported too. You just have to call <<<mockControl.useFreeMarkerTemplateProcessor()>>>.
   
** Context Variables

   Context Variables is another tool how to parametrize the response. It's possible to define variables in the test script and use them in the template. Request Variables can be used both in 
   request and response templates.
   
---
	@Test
	public void testContext()
	{
		mockControl
			.setTestContextAttribute("a", 1)
			.setTestContextAttribute("b", 4)
			.useFreeMarkerTemplateProcessor()
			.expectRequest("request-context.xml")
			.returnResponse("response2.xml");
		
		int result = calc.plus(1, 4);
		assertEquals(5, result);
		
		mockControl.verify();
	}
---

FreeMarker template could look like this

---
<plus xmlns="http://javacrumbs.net/calc">
  <a>${a}</a>
  <b>${b}</b>
</plus>
---

It can be also used in XSLT this way

---
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:param name="a"/>
        <xsl:param name="b"/>
        <xsl:template match="/">
			<plus xmlns="http://javacrumbs.net/calc">
			  <a><xsl:value-of select="$a"/></a>
			  <b><xsl:value-of select="$b"/></b>
			</plus>
		</xsl:template>
</xsl:stylesheet>
---   

** Multiple Calls
  
   It's also possible to test multiple calls of a WS in one test. The most straightforward approach is this
   
---
@Test
public void testMultiple()
{
	mockControl.expectRequest("request-ignore.xml")
		.returnResponse("response2.xml")
		.returnResponse("response3.xml");
	
	assertEquals(5, calc.plus(2, 3));
	assertEquals(8, calc.plus(3, 5));
			
	mockControl.verify();
}
---
   
   
   but it's possible to define number of calls for each response
   
---
@Test
public void testMultipleTemplate()
{
	mockControl.expectRequest("request-ignore.xml").returnResponse("response-template.xml").atLeastOnce();
	
	assertEquals(5, calc.plus(2, 3));
	assertEquals(8, calc.plus(3, 5));
	
	mockControl.verify();
}
---
	
   
   
          


   
   
   
       
   
   