  {{{http://mvnindex.org/spring-ws-test-files/spring-ws-test-0.2.jar}Download}}

  {{{https://java-crumbs.svn.sourceforge.net/svnroot/java-crumbs/spring-ws-test-sample/trunk/}Sample application}}

Spring Web Service Test
  
  Goal of Spring Web Service Test project is to simplify functional testing of Spring WS client application. It's useful when you want to test
  an application that calls external services using Spring WS. Until now, you had basically two choices. You could either call test instance of the WS or 
  you could create a mock WS using SoapUI, WSUnit or similar tool. Both of those approaches have one big fault. You have to depend on an external service
  running when executing your test. It makes test configuration much more complex and error prone.
  
  Spring Web Service Mock gives you the opportunity to write functional test using JUnit and Spring test support. Mock responses are generated internally, in the same
  JVM, therefore the setup is much easier. 
  
  This project can be used mainly in the following scenarios:
  
  * Tests of Spring configuration. Unit test are nice and useful but we also need to test the configuration. Spring WS Test gives you the opportunity to test most of the configuration without having to depend on external systems running.
 
  * Test Driven Development. You can define application in terms of requests sent and reactions on responses received. Using Spring WS Test makes it much easier.
 
  * ...
  
Tutorial

	Let's imagine that we write Airline Aggregator application. This application calls underlying Airline web services and aggregates the results. It is possible to write Unit test, but let's imagine that we want to write
	more complex automated tests, that include actual external WS call. We have to generate mock responses.
	
	First of all, we have to configure the WebServiceTemplate like this
	
---
	<bean id="wsTemplate" class="org.springframework.ws.client.core.WebServiceTemplate">
		<property name="messageSender" ref="messageSender"/>
		<!-- Other settings here -->
	</bean>	
---     

* Simple mock response

	In other configuration file we can define the <<<messageSender>>> like <<<HttpUrlMessageSender>>> that does the actual HTTP call.  For test we can define
	mock message sender that generates mock responses instead of actually sending the request over HTTP. We can for example set up a message sender like this.
	
---
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:swst="http://net.javacrumbs/schema/spring-ws-test"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
		http://net.javacrumbs/schema/spring-ws-test http://net.javacrumbs/schema/spring-ws-test.xsd">

	<bean id="mock-sender" class="net.krecan.springws.test.MockWebServiceMessageSender"/>
	
	<swst:response-generator>
		<swst:namespaces>
			soapenv=http://schemas.xmlsoap.org/soap/envelope/
			ns=http://www.springframework.org/spring-ws/samples/airline/schemas/messages
		</swst:namespaces>
		<swst:xpaths>
			concat('mock-responses/',$uri.host, '/', local-name(//soapenv:Body/*[1]),'/',//ns:from,'-',//ns:to,'-response.xml')
			concat('mock-responses/',$uri.host, '/', local-name(//soapenv:Body/*[1]),'/default-response.xml')
		</swst:xpaths>
	</swst:response-generator>
	...
</beans>
---  

  This definition says that for every request the XPath <<<concat('mock-responses/',$uri.host, '/', local-name(//soapenv:Body/*[1]),'/',//ns:from,'-',//ns:to,'-response.xml')>>> should be evaluated first.
  Result of the evaluation can be for example <<<mock-responses/www.csa.cz/GetFlightsRequest/PRG-JFK-response.xml>>>. If this file exists, its content will be returned as 
  the response. If the file does not exists, next XPath expression is evaluated. If even <<<mock-responses/www.csa.cz/GetFlightsRequest/default-response.xml>>> does not exist, an exception is thrown.
  
  If we have this or similar configuration, adding an extra mock response consists only from creating new file with correct path and name.
  
  Please note that MockWebServiceMessageSender is automatically looking for all RequestValidator instances in the application context. Also note that 
  instead of using swst XML schema you can use net.krecan.springws.test.generator.DefaultResponseGeneratorFactoryBean.
  
* XSLT mock response
  
  Sometimes creating an extra response file for every possible request is just too much work. Sometime you just need to tweak the response a bit before using it. 
  Luckily you can use a XSLT template to generate the response based on the request. For example you can specify response like this
  
---
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
	<xsl:param name="departureTime"/>
	<xsl:template match="/">
		<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
			<soapenv:Header />
			<soapenv:Body>
				<GetFlightsResponse
					xmlns="http://www.springframework.org/spring-ws/samples/airline/schemas/messages"
					xmlns:msg="http://www.springframework.org/spring-ws/samples/airline/schemas/messages"
					xmlns:tps="http://www.springframework.org/spring-ws/samples/airline/schemas/types">
					<flight>
						<tps:number>OK0651</tps:number>
						<tps:departureTime><xsl:value-of select="$departureTime"/></tps:departureTime>
						<tps:from>
							<tps:code>PRG</tps:code>
							<tps:name>Prague</tps:name>
							<tps:city>Prague</tps:city>
						</tps:from>
						<tps:arrivalTime>2001-12-31T12:00:00
						</tps:arrivalTime>
						<tps:to>
							<tps:code>CDG</tps:code>
							<tps:name>CDG</tps:name>
							<tps:city>Paris</tps:city>
						</tps:to>
						<tps:serviceClass><xsl:value-of select="//msg:serviceClass"/></tps:serviceClass>
					</flight>
				</GetFlightsResponse>
			</soapenv:Body>
		</soapenv:Envelope>
	</xsl:template>
</xsl:stylesheet>
---

  Instead of simple XML response, we have XSLT that uses the <<<serviceClass>>> from the request and <<<departureTime>>> from the test context
  (more about the context later).   
  
* Validating request

  In the case you want to validate requests. You can configure request validator. Currently, two validators are supported.
  
** SchemaRequestValidator

  Schema request validator validates whether the request conforms to given schema 
  
---
	<swst:schema-validator>
		<swst:schemas>
			xml/schema.xsd
	    </swst:schemas>
	</swst:schema-validator>
---	

   When configured like this, every request is validated using specified schemas. If the request is not valid <<<WsTestException>>> is thrown.
   
** XmlCompareRequestValidator

  You can find this validator useful for Test Driven Development. It compares the request with specified file 
  
---
	<swst:compare-request-validator>
		<swst:namespaces>
			soapenv=http://schemas.xmlsoap.org/soap/envelope/
			ns=http://www.springframework.org/spring-ws/samples/airline/schemas/messages
		</swst:namespaces>
		<swst:xpaths>
			concat('mock-responses/',$uri.host, '/', local-name(//soapenv:Body/*[1]),'/',//ns:from,'-',//ns:to,'-request.xml')
		</swst:xpaths>
	</swst:compare-request-validator>
---

  It's similar to the request generator, only instead of generating responses it validates the request. You can use XSLT templates here as well. 
  You can also specify special placeholder <<<${IGNORE}>>> for values that should be ignored.

* Test context

  Test context is useful, when you need to use some specific configuration. For example you want to set expected departure time and use it in the response.
 
---
WsTestContextHolder.getTestContext().setAttribute("departureTime", "2009-07-14");
--- 

  You can set the attribute in the test method and then use it 
  
  * In the XSLT template as a template parameter.
  
  * In the XPath using <<<$context.departureTime>>>
  
  * Programatically
  
  It's a good idea to clear the test context at the tearDown() method.
  
    
     